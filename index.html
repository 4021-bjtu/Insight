<!DOCTYPE html>
<html>

<head>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            font-family: 'MyFont', sans-serif;
        }

        @font-face {
            font-family: 'MyFont';
            src: url('../assets/font/font_2.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        .dot {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: blue;
            transform: translate(-50%, -50%);
            transition: width 0.2s, height 0.2s, background-color 0.2s;
            pointer-events: none;
            will-change: transform, width, height, background-color;
        }

        .iframe-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        .frame {
            position: absolute;
            width: 100%;
            height: 100%;
            border: none;
            opacity: 0;
            transform: translateX(0);
            transition: all 1s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: opacity;
        }

        .frame.active {
            opacity: 1;
            z-index: 2;
        }

        .frame.exit {
            opacity: 0;
        }

        .fade-enter {
            opacity: 0;
        }

        #calibrationInstruction {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            text-align: center;
            z-index: 1000;
            display: none;
            will-change: transform;
        }

        #calibrationPoint {
            position: fixed;
            width: 20px;
            height: 20px;
            background: #ff4757;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 1001;
            will-change: transform, background-color;
        }

        #gazePoint {
            position: fixed;
            width: 15px;
            height: 15px;
            background: #5e6ad2;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 999;
            pointer-events: none;
            will-change: transform;
        }

        .camera-preview {
            position: absolute;
            top: -9999px;
            left: -9999px;
            opacity: 0;
            pointer-events: none;
        }

        #webcam {
            width: 320px;
            height: 240px;
        }
    </style>
    <script src="/assets/js/camera_utils.js" crossorigin="anonymous"></script>
    <script src="/assets/js/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="/assets/js/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="/assets/js/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@magenta/image@0.2.1/dist/magentaimage.min.js"></script>
</head>

<body>
    <div class="container">
        <div class="camera-preview" style="display: none;">
            <video id="webcam" autoplay playsinline muted></video>
        </div>
        <div style="display: none;">
            <button id="webcamButton" class="mdc-button">å¯ç”¨æ‘„åƒå¤´</button>
            <button id="calibrateButton" class="mdc-button">å¼€å§‹æ ¡å‡†</button>
            <button id="clearCalibrationButton" class="mdc-button">é‡æ–°æ ¡å‡†</button>
        </div>
        <div id="calibrationInstruction">
            è¯·æ³¨è§†çº¢ç‚¹åæŒ‰ç©ºæ ¼é”®<br>ï¼ˆ5/5ï¼‰
        </div>
        <!-- <div id="dot" class="dot" style="z-index: 99999999;"></div> -->
        <div id="calibrationPoint"></div>
        <div id="gazePoint"></div>
    </div>

    <div class="iframe-container" id="container">
        <iframe class="frame" id="frame1"></iframe>
        <iframe class="frame" id="frame2"></iframe>
    </div>

    <script type="module">
        // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ RAF ç®¡ç†å™¨é¿å…é‡å¤è°ƒç”¨
        class RAFManager {
            constructor() {
                this.isRunning = false;
                this.callbacks = new Set();
            }

            add(callback) {
                this.callbacks.add(callback);
                if (!this.isRunning) {
                    this.start();
                }
            }

            remove(callback) {
                this.callbacks.delete(callback);
                if (this.callbacks.size === 0) {
                    this.stop();
                }
            }

            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.tick();
            }

            stop() {
                this.isRunning = false;
            }

            tick() {
                if (!this.isRunning) return;

                this.callbacks.forEach(callback => {
                    try {
                        callback();
                    } catch (err) {
                        console.error('RAF callback error:', err);
                    }
                });

                if (this.isRunning) {
                    requestAnimationFrame(() => this.tick());
                }
            }
        }

        const rafManager = new RAFManager();

        // æ€§èƒ½ä¼˜åŒ–ï¼šèŠ‚æµå‡½æ•°
        function throttle(func, delay) {
            let lastCall = 0;
            return function (...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    return func.apply(this, args);
                }
            };
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šé˜²æŠ–å‡½æ•°
        function debounce(func, delay) {
            let timeoutId;
            return function (...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };
        }

        //iFrameæ§åˆ¶
        const iframeManager = (() => {
            let currentFrame = null;
            let nextFrame = null;

            const init = () => {
                const frames = document.querySelectorAll('.frame');
                currentFrame = frames[0];
                nextFrame = frames[1];
            };

            const preload = async (url) => {
                return new Promise((resolve) => {
                    nextFrame.src = url;
                    nextFrame.onload = () => {
                        injectAPI(nextFrame);
                        resolve();
                    };
                    // æ·»åŠ é”™è¯¯å¤„ç†
                    nextFrame.onerror = () => {
                        console.error('Failed to load iframe:', url);
                        resolve();
                    };
                });
            };

            const injectAPI = (frame) => {
                try {
                    frame.contentWindow.parentHost = {
                        send: (data) => console.log('æ”¶åˆ°å­é¡µé¢æ•°æ®:', data),
                        switchPage: (url, animation) => switchPage(url, animation)
                    };
                } catch (err) {
                    console.warn('Failed to inject API:', err);
                }
            };

            const switchPage = async (url, animation = 'fade') => {
                if (url == null) {
                    return
                }
                await preload(url);
                nextFrame.className = `frame ${animation}-enter`;
                currentFrame.classList.add('exit');
                nextFrame.classList.add('active');

                setTimeout(() => {
                    currentFrame.classList.remove('active', 'exit');
                    [currentFrame, nextFrame] = [nextFrame, currentFrame];
                }, 600);
            };

            const getCurrentFrame = () => {
                return currentFrame;
            };

            return { init, switchPage, getCurrentFrame };
        })();

        //iFrameåˆå§‹åŒ–
        iframeManager.init();

        //-----------------é¢éƒ¨è¯†åˆ«+çœ¼åŠ¨è·Ÿè¸ª------------------
        import vision from "./assets/js/mediapipe_tasks-vision@0.10.3.js";
        const { FaceLandmarker, FaceDetector, FilesetResolver } = vision;

        const gazePointElement = document.getElementById("gazePoint");
        const calibrationPointElement = document.getElementById("calibrationPoint");
        const calibrationInstructionElement = document.getElementById("calibrationInstruction");

        let faceDetector;
        let faceLandmarker;
        let debug = true;
        let face_model_load_state = false;
        let iris_model_load_state = false;
        let hand_model_load_state = false;
        let runningMode = "VIDEO";
        let calibrateButton;
        let clearCalibrationButton;
        let webcamRunning = false;
        const videoWidth = 480;

        // æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜ DOM å…ƒç´ 
        const video = document.getElementById("webcam");

        // --- Gaze Calculation Variables ---
        let smoothedGazeX = window.innerWidth / 2;
        let smoothedGazeY = window.innerHeight / 2;
        const SMOOTHING_FACTOR = 1;

        // Default gaze parameters (will be overwritten by calibration)
        let calibratedGazeParams = {
            minRelX: 0.35,
            maxRelX: 0.65,
            minRelY: 0.35,
            maxRelY: 0.65,
            invertX: true,
            invertY: false
        };

        // --- Calibration Variables ---
        let isCalibrating = false;
        let calibrationState = "idle";
        let currentCalibrationPointIndex = 0;
        const CALIBRATION_SAMPLES_PER_POINT = 60;
        let samplesCollectedThisPoint = 0;
        let accumulatedRelX = 0;
        let accumulatedRelY = 0;
        let calibrationDataEye = [];

        const CALIBRATION_POINT_SCREEN_COORDS = [
            { x: 0.05, y: 0.05 },
            { x: 0.95, y: 0.05 },
            { x: 0.95, y: 0.95 },
            { x: 0.05, y: 0.95 }
        ];

        // æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜è®¡ç®—ç»“æœ
        const landmarkCache = new Map();
        const CACHE_DURATION = 16; // çº¦1å¸§çš„æ—¶é—´

        async function createFaceLandmarker() {
            try {
                const filesetResolver = await FilesetResolver.forVisionTasks("/assets/wasm");
                faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                    baseOptions: {
                        modelAssetPath: `./assets/module/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: false, // æ€§èƒ½ä¼˜åŒ–ï¼šç¦ç”¨ä¸éœ€è¦çš„è¾“å‡º
                    outputFacialTransformationMatrixes: false,
                    runningMode,
                    numFaces: 1
                });
                console.log("FaceLandmarker created successfully");
                loadCalibrationData();
            } catch (err) {
                console.error("Failed to create FaceLandmarker:", err);
            }
        }
        createFaceLandmarker();

        const initializefaceDetector = async () => {
            try {
                const vision = await FilesetResolver.forVisionTasks("/assets/wasm");
                faceDetector = await FaceDetector.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `/assets/module/blaze_face_short_range.tflite`,
                        delegate: "GPU"
                    },
                    runningMode: runningMode
                });
            } catch (err) {
                console.error("Failed to initialize face detector:", err);
            }
        };
        initializefaceDetector();

        function hasGetUserMedia() {
            return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        }

        if (hasGetUserMedia()) {
            calibrateButton = document.getElementById("calibrateButton");
            clearCalibrationButton = document.getElementById("clearCalibrationButton");

            calibrateButton?.addEventListener("click", startCalibration);
            clearCalibrationButton?.addEventListener("click", clearCalibration);
        } else {
            console.warn("getUserMedia() is not supported by your browser");
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨æ›´é«˜æ•ˆçš„æ‘„åƒå¤´ç®¡ç†
        async function face_enableCam(event) {
            if (!faceDetector) {
                console.warn("Face Detector is still loading. Please try again..");
                return;
            }

            if (webcamRunning === true) {
                webcamRunning = false;
                rafManager.remove(face_predictWebcam);
                await stopVideoStream();
            } else {
                webcamRunning = true;
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: 640,
                            height: 480,
                            frameRate: { ideal: 30, max: 30 } // æ€§èƒ½ä¼˜åŒ–ï¼šé™åˆ¶å¸§ç‡
                        }
                    });
                    video.srcObject = stream;
                    rafManager.add(face_predictWebcam);
                } catch (err) {
                    console.error("Error accessing webcam: ", err);
                    webcamRunning = false;
                }
            }
        }

        async function enableCam(event) {
            if (!faceLandmarker) {
                console.log("Wait! faceLandmarker not loaded yet.");
                return;
            }

            if (webcamRunning === true) {
                webcamRunning = false;
                if (calibrateButton) calibrateButton.style.display = "none";
                if (clearCalibrationButton) clearCalibrationButton.style.display = "none";
                await stopVideoStream();
                gazePointElement.style.display = "none";
                stopCalibration();
                rafManager.remove(predictWebcam);
            } else {
                webcamRunning = true;
                if (calibrateButton) calibrateButton.style.display = "inline-block";
                if (clearCalibrationButton) clearCalibrationButton.style.display = "inline-block";

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: 640,
                            height: 480,
                            frameRate: { ideal: 30, max: 30 }
                        }
                    });
                    video.srcObject = stream;
                    rafManager.add(predictWebcam);
                } catch (err) {
                    console.error("Error accessing webcam: ", err);
                    webcamRunning = false;
                    if (calibrateButton) calibrateButton.style.display = "none";
                    if (clearCalibrationButton) clearCalibrationButton.style.display = "none";
                }
            }
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šç»Ÿä¸€çš„è§†é¢‘æµåœæ­¢å‡½æ•°
        async function stopVideoStream() {
            if (video.srcObject) {
                video.pause();
                await new Promise(resolve => setTimeout(resolve, 50));
                video.srcObject.getTracks().forEach(track => {
                    track.stop();
                    track.enabled = false;
                });
                video.srcObject = null;
            }
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜å”¯ä¸€ç´¢å¼•è®¡ç®—
        const uniqueIndicesCache = new Map();
        function getUniqueLandmarkIndices(connectorConstant) {
            if (!connectorConstant) return [];

            const cacheKey = connectorConstant.toString();
            if (uniqueIndicesCache.has(cacheKey)) {
                return uniqueIndicesCache.get(cacheKey);
            }

            const result = [...new Set(connectorConstant.flatMap(conn => [conn.start, conn.end]))];
            uniqueIndicesCache.set(cacheKey, result);
            return result;
        }

        function getAveragePosition(landmarks, indices) {
            if (!landmarks || indices.length === 0) return null;
            let sumX = 0, sumY = 0, sumZ = 0;
            let count = 0;
            for (const index of indices) {
                if (landmarks[index]) {
                    sumX += landmarks[index].x;
                    sumY += landmarks[index].y;
                    sumZ += landmarks[index].z;
                    count++;
                }
            }
            return count > 0 ? { x: sumX / count, y: sumY / count, z: sumZ / count } : null;
        }

        function getMinMaxBoundingBox(landmarks, indices) {
            if (!landmarks || indices.length === 0) return null;
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            let count = 0;
            for (const index of indices) {
                if (landmarks[index]) {
                    minX = Math.min(minX, landmarks[index].x);
                    maxX = Math.max(maxX, landmarks[index].x);
                    minY = Math.min(minY, landmarks[index].y);
                    maxY = Math.max(maxY, landmarks[index].y);
                    count++;
                }
            }
            return count > 0 ? { minX, maxX, minY, maxY } : null;
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜è™¹è†œä½ç½®è®¡ç®—ç»“æœ
        let lastIrisCalculationTime = 0;
        let cachedIrisPosition = null;

        function getRawRelativeIrisPosition(faceLandmarks) {
            const now = performance.now();
            if (now - lastIrisCalculationTime < CACHE_DURATION && cachedIrisPosition) {
                return cachedIrisPosition;
            }

            if (!faceLandmarks || faceLandmarks.length === 0) return null;

            const leftIrisIndices = getUniqueLandmarkIndices(FaceLandmarker.FACE_LANDMARKS_LEFT_IRIS);
            const rightIrisIndices = getUniqueLandmarkIndices(FaceLandmarker.FACE_LANDMARKS_RIGHT_IRIS);
            const leftEyeOutlineIndices = getUniqueLandmarkIndices(FaceLandmarker.FACE_LANDMARKS_LEFT_EYE);
            const rightEyeOutlineIndices = getUniqueLandmarkIndices(FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE);

            const leftIrisCenter = getAveragePosition(faceLandmarks, leftIrisIndices);
            const rightIrisCenter = getAveragePosition(faceLandmarks, rightIrisIndices);
            const leftEyeBox = getMinMaxBoundingBox(faceLandmarks, leftEyeOutlineIndices);
            const rightEyeBox = getMinMaxBoundingBox(faceLandmarks, rightEyeOutlineIndices);

            let relativeIrisX = [];
            let relativeIrisY = [];

            if (leftIrisCenter && leftEyeBox) {
                const eyeWidth = leftEyeBox.maxX - leftEyeBox.minX;
                const eyeHeight = leftEyeBox.maxY - leftEyeBox.minY;
                if (eyeWidth > 0.001 && eyeHeight > 0.001) {
                    relativeIrisX.push((leftIrisCenter.x - leftEyeBox.minX) / eyeWidth);
                    relativeIrisY.push((leftIrisCenter.y - leftEyeBox.minY) / eyeHeight);
                }
            }
            if (rightIrisCenter && rightEyeBox) {
                const eyeWidth = rightEyeBox.maxX - rightEyeBox.minX;
                const eyeHeight = rightEyeBox.maxY - rightEyeBox.minY;
                if (eyeWidth > 0.001 && eyeHeight > 0.001) {
                    relativeIrisX.push((rightIrisCenter.x - rightEyeBox.minX) / eyeWidth);
                    relativeIrisY.push((rightIrisCenter.y - rightEyeBox.minY) / eyeHeight);
                }
            }

            if (relativeIrisX.length === 0) {
                cachedIrisPosition = null;
                return null;
            }

            const avgRelX = relativeIrisX.reduce((a, b) => a + b, 0) / relativeIrisX.length;
            const avgRelY = relativeIrisY.reduce((a, b) => a + b, 0) / relativeIrisY.length;

            cachedIrisPosition = { avgRelX, avgRelY };
            lastIrisCalculationTime = now;
            return cachedIrisPosition;
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šèŠ‚æµè§†çº¿è®¡ç®—å’ŒDOMæ›´æ–°
        const throttledGazeUpdate = throttle((x, y) => {
            gazePointElement.style.left = `${x}px`;
            gazePointElement.style.top = `${y}px`;
        }, 16); // çº¦60fps

        const throttledGazeMessage = throttle((x, y) => {
            try {
                const currentFrame = iframeManager.getCurrentFrame();
                if (currentFrame?.contentWindow) {
                    currentFrame.contentWindow.postMessage(`gaze_${x}|${y}`, '*');
                }
            } catch (err) {
                // å¿½ç•¥è·¨åŸŸé”™è¯¯
            }
        }, 33); // çº¦30fps

        function calculateGaze(faceLandmarks) {
            if (isCalibrating && calibrationState !== 'collecting_samples') {
                gazePointElement.style.display = "none";
                return;
            }

            const rawIrisPos = getRawRelativeIrisPosition(faceLandmarks);
            if (!rawIrisPos) {
                gazePointElement.style.display = "none";
                return;
            }

            if (isCalibrating && calibrationState === 'collecting_samples') {
                accumulatedRelX += rawIrisPos.avgRelX;
                accumulatedRelY += rawIrisPos.avgRelY;
                samplesCollectedThisPoint++;

                // æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘DOMæ“ä½œé¢‘ç‡
                if (samplesCollectedThisPoint % 5 === 0) {
                    const flashColor = (samplesCollectedThisPoint % 10) < 5 ? "lime" : "red";
                    calibrationPointElement.style.backgroundColor = flashColor;
                }

                if (samplesCollectedThisPoint >= CALIBRATION_SAMPLES_PER_POINT) {
                    const avgCalibRelX = accumulatedRelX / samplesCollectedThisPoint;
                    const avgCalibRelY = accumulatedRelY / samplesCollectedThisPoint;
                    calibrationDataEye.push({ avgRelX: avgCalibRelX, avgRelY: avgCalibRelY });

                    currentCalibrationPointIndex++;
                    if (currentCalibrationPointIndex < CALIBRATION_POINT_SCREEN_COORDS.length) {
                        setupNextCalibrationPoint();
                    } else {
                        finalizeCalibration();
                    }
                }
                return;
            }

            const { avgRelX, avgRelY } = rawIrisPos;
            const params = calibratedGazeParams;

            let normEyeX = (avgRelX - params.minRelX) / (params.maxRelX - params.minRelX);
            let normEyeY = (avgRelY - params.minRelY) / (params.maxRelY - params.minRelY);

            normEyeX = Math.max(0, Math.min(1, normEyeX));
            normEyeY = Math.max(0, Math.min(1, normEyeY));

            let screenNormX = params.invertX ? (1.0 - normEyeX) : normEyeX;
            let screenNormY = params.invertY ? (1.0 - normEyeY) : normEyeY;

            const targetGazeX = screenNormX * window.innerWidth;
            const targetGazeY = screenNormY * window.innerHeight;

            smoothedGazeX = SMOOTHING_FACTOR * targetGazeX + (1 - SMOOTHING_FACTOR) * smoothedGazeX;
            smoothedGazeY = SMOOTHING_FACTOR * targetGazeY + (1 - SMOOTHING_FACTOR) * smoothedGazeY;

            throttledGazeUpdate(smoothedGazeX, smoothedGazeY);
            throttledGazeMessage(smoothedGazeX, smoothedGazeY);
        }

        function startCalibration() {
            if (!webcamRunning) {
                alert("Please enable the webcam first.");
                return;
            }
            isCalibrating = true;
            calibrationDataEye = [];
            currentCalibrationPointIndex = 0;
            gazePointElement.style.display = "none";
            calibrationInstructionElement.style.display = "block";
            if (calibrateButton) {
                calibrateButton.innerText = "CALIBRATING...";
                calibrateButton.disabled = true;
            }
            setupNextCalibrationPoint();
        }

        function setupNextCalibrationPoint() {
            calibrationState = "waiting_for_input";
            samplesCollectedThisPoint = 0;
            accumulatedRelX = 0;
            accumulatedRelY = 0;

            const point = CALIBRATION_POINT_SCREEN_COORDS[currentCalibrationPointIndex];
            calibrationPointElement.style.left = `${point.x * 100}%`;
            calibrationPointElement.style.top = `${point.y * 100}%`;
            calibrationPointElement.style.backgroundColor = "red";
            calibrationPointElement.style.display = "block";
            calibrationInstructionElement.innerHTML = `è¯·é›†ä¸­æ³¨æ„åŠ›åœ¨çº¢ç‚¹å¤„ (${currentCalibrationPointIndex + 1}/${CALIBRATION_POINT_SCREEN_COORDS.length})`;
            setTimeout(() => {
                calibrationState = "collecting_samples";
            }, 1000);
        }

        function finalizeCalibration() {
            isCalibrating = false;
            calibrationState = "idle";
            calibrationPointElement.style.display = "none";
            calibrationInstructionElement.style.display = "none";
            gazePointElement.style.display = "block";

            if (calibrateButton) {
                calibrateButton.innerText = "RECALIBRATE";
                calibrateButton.disabled = false;
            }

            if (calibrationDataEye.length !== CALIBRATION_POINT_SCREEN_COORDS.length) {
                console.error("Calibration data mismatch. Using defaults.");
                calibratedGazeParams = { minRelX: 0.35, maxRelX: 0.65, minRelY: 0.35, maxRelY: 0.65, invertX: true, invertY: false };
                saveCalibrationData();
                return;
            }

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            calibrationDataEye.forEach(p => {
                minX = Math.min(minX, p.avgRelX);
                maxX = Math.max(maxX, p.avgRelX);
                minY = Math.min(minY, p.avgRelY);
                maxY = Math.max(maxY, p.avgRelY);
            });

            calibratedGazeParams.minRelX = minX;
            calibratedGazeParams.maxRelX = maxX;
            calibratedGazeParams.minRelY = minY;
            calibratedGazeParams.maxRelY = maxY;

            const avgLeftScreenEyeX = (calibrationDataEye[0].avgRelX + calibrationDataEye[3].avgRelX) / 2;
            const avgRightScreenEyeX = (calibrationDataEye[1].avgRelX + calibrationDataEye[2].avgRelX) / 2;
            calibratedGazeParams.invertX = avgLeftScreenEyeX > avgRightScreenEyeX;

            const avgTopScreenEyeY = (calibrationDataEye[0].avgRelY + calibrationDataEye[1].avgRelY) / 2;
            const avgBottomScreenEyeY = (calibrationDataEye[2].avgRelY + calibrationDataEye[3].avgRelY) / 2;
            calibratedGazeParams.invertY = avgTopScreenEyeY > avgBottomScreenEyeY;

            console.log("Calibration complete. New params:", calibratedGazeParams);

            try {
                const currentFrame = iframeManager.getCurrentFrame();
                if (currentFrame?.contentWindow) {
                    currentFrame.contentWindow.postMessage('finish_calibration', '*');
                }
            } catch (err) {
                // å¿½ç•¥è·¨åŸŸé”™è¯¯
            }

            saveCalibrationData();
        }

        function stopCalibration() {
            isCalibrating = false;
            calibrationState = "idle";
            calibrationPointElement.style.display = "none";
            calibrationInstructionElement.style.display = "none";
            if (calibrateButton) {
                calibrateButton.innerText = "START CALIBRATION";
                calibrateButton.disabled = false;
            }
        }

        function saveCalibrationData() {
            try {
                localStorage.setItem("faceGazeCalibrationParams", JSON.stringify(calibratedGazeParams));
                console.log("Calibration data saved.");
            } catch (err) {
                console.error("Failed to save calibration data:", err);
            }
        }

        function loadCalibrationData() {
            try {
                const storedData = localStorage.getItem("faceGazeCalibrationParams");
                if (storedData) {
                    calibratedGazeParams = JSON.parse(storedData);
                    console.log("Loaded calibration data:", calibratedGazeParams);
                    if (calibrateButton) calibrateButton.innerText = "RECALIBRATE";
                } else {
                    console.log("No saved calibration data found. Using defaults.");
                }
            } catch (err) {
                console.error("Failed to load calibration data:", err);
            }
        }

        function clearCalibration() {
            try {
                localStorage.removeItem("faceGazeCalibrationParams");
                calibratedGazeParams = {
                    minRelX: 0.35, maxRelX: 0.65, minRelY: 0.35, maxRelY: 0.65,
                    invertX: true, invertY: false
                };
                console.log("Calibration data cleared. Reset to defaults.");
                alert("Calibration data cleared. Using default settings. Recalibrate for best results.");
                if (calibrateButton) calibrateButton.innerText = "START CALIBRATION";
            } catch (err) {
                console.error("Failed to clear calibration data:", err);
            }
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ç‹¬ç«‹çš„æ—¶é—´æˆ³å’Œç»“æœç¼“å­˜
        let lastFaceDetectionTime = 0;
        let lastGazeDetectionTime = 0;
        let results = undefined;
        let lastResults = undefined;

        function face_predictWebcam() {
            if (!webcamRunning || !video.videoWidth) return;

            let startTimeMs = performance.now();
            if (video.currentTime !== lastFaceDetectionTime) {
                lastFaceDetectionTime = video.currentTime;

                try {
                    const detections = faceDetector.detectForVideo(video, startTimeMs).detections;
                    if (detections.length > 0) {
                        const firstFace = detections[0];
                        const nose = firstFace.keypoints[2];
                        const message = {
                            type: "face_point",
                            x: nose.x,
                            y: nose.y,
                        };

                        try {
                            const currentFrame = iframeManager.getCurrentFrame();
                            if (currentFrame?.contentWindow) {
                                currentFrame.contentWindow.postMessage(message, '*');
                            }
                        } catch (err) {
                            // å¿½ç•¥è·¨åŸŸé”™è¯¯
                        }
                    }
                } catch (err) {
                    console.warn("Face detection error:", err);
                }
            }
        }

        function predictWebcam() {
            if (!webcamRunning || !video.videoWidth) return;

            let startTimeMs = performance.now();
            if (video.currentTime !== lastGazeDetectionTime) {
                lastGazeDetectionTime = video.currentTime;

                try {
                    results = faceLandmarker.detectForVideo(video, startTimeMs);
                } catch (err) {
                    console.warn("Gaze detection error:", err);
                    return;
                }
            }

            if (results && results.faceLandmarks) {
                for (const landmarks of results.faceLandmarks) {
                    calculateGaze(landmarks);
                }
            } else {
                if (!isCalibrating) gazePointElement.style.display = "none";
            }
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šé˜²æŠ–çª—å£è°ƒæ•´äº‹ä»¶
        const debouncedWindowResize = debounce(() => {
            smoothedGazeX = window.innerWidth / 2;
            smoothedGazeY = window.innerHeight / 2;
            if (gazePointElement && gazePointElement.style.display === 'block' && !isCalibrating) {
                gazePointElement.style.left = `${smoothedGazeX}px`;
                gazePointElement.style.top = `${smoothedGazeY}px`;
            }
            if (isCalibrating) {
                alert("Window resized during calibration. Please restart calibration.");
                stopCalibration();
            }
        }, 250);

        window.addEventListener('load', () => {
            smoothedGazeX = window.innerWidth / 2;
            smoothedGazeY = window.innerHeight / 2;
            if (gazePointElement) {
                gazePointElement.style.left = `${smoothedGazeX}px`;
                gazePointElement.style.top = `${smoothedGazeY}px`;
            }
        });

        window.addEventListener('resize', debouncedWindowResize);

        //-----------------é¢éƒ¨è¯†åˆ«+çœ¼åŠ¨è·Ÿè¸ªç»“æŸ------------------

        

        //-----------------é¢„å…ˆåŠ è½½æ¨¡å‹æµç¨‹------------------
        let isPreloading = false;

        // æ€§èƒ½ä¼˜åŒ–ï¼šæ”¹è¿›çš„æ¨¡å‹é¢„åŠ è½½æµç¨‹
        async function preloadModels() {
            if (isPreloading) return;
            isPreloading = true;

            console.log('å¼€å§‹é¢„åŠ è½½æ¨¡å‹...');

            try {
                // 1. é¢„åŠ è½½è„¸éƒ¨æ£€æµ‹æ¨¡å‹
                console.log('é¢„åŠ è½½è„¸éƒ¨æ£€æµ‹æ¨¡å‹...');
                const stream1 = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240 } // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨è¾ƒå°åˆ†è¾¨ç‡
                });
                const tempVideo1 = document.createElement('video');
                tempVideo1.srcObject = stream1;
                tempVideo1.muted = true;

                await new Promise(resolve => {
                    tempVideo1.onloadedmetadata = () => {
                        face_enableCam();
                        setTimeout(() => {
                            face_enableCam();
                            stream1.getTracks().forEach(track => track.stop());
                            resolve();
                        }, 800); // å‡å°‘ç­‰å¾…æ—¶é—´
                    };
                });

                // 2. é¢„åŠ è½½è™¹è†œæ£€æµ‹æ¨¡å‹
                console.log('é¢„åŠ è½½è™¹è†œæ£€æµ‹æ¨¡å‹...');
                const stream2 = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240 }
                });
                const tempVideo2 = document.createElement('video');
                tempVideo2.srcObject = stream2;
                tempVideo2.muted = true;

                await new Promise(resolve => {
                    tempVideo2.onloadedmetadata = () => {
                        enableCam();
                        setTimeout(() => {
                            enableCam();
                            stream2.getTracks().forEach(track => track.stop());
                            resolve();
                        }, 800);
                    };
                });


                console.log('æ‰€æœ‰æ¨¡å‹é¢„åŠ è½½å®Œæˆ');

                setTimeout(() => {
                    try {
                        const currentFrame = iframeManager.getCurrentFrame();
                        if (currentFrame?.contentWindow) {
                            currentFrame.contentWindow.postMessage('finish_webcam', '*');
                        }
                    } catch (err) {
                        // å¿½ç•¥è·¨åŸŸé”™è¯¯
                    }
                }, 800);

            } catch (err) {
                console.error('æ¨¡å‹é¢„åŠ è½½å¤±è´¥:', err);
            }
        }

        //-----------------é¢„å…ˆåŠ è½½æ¨¡å‹æµç¨‹ç»“æŸ------------------
        let img_url = "/assets/img/1.jpg";
        let after_img_url = "";
        /**
         * å›¾åƒé£æ ¼åŒ–å¤„ç†å‡½æ•°
         * @param {string} contentBlobUrl - å†…å®¹å›¾ç‰‡çš„Blob URL
         * @returns {Promise<string>} - è¿”å›é£æ ¼åŒ–åçš„å›¾ç‰‡Blob URL
         */
        async function stylizeImage(contentBlobUrl) {
            // åˆå§‹åŒ–æ¨¡å‹å’Œç”»å¸ƒ
            const model = new mi.ArbitraryStyleTransferNetwork();
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // åŠ è½½é£æ ¼å›¾ç‰‡ï¼ˆå›ºå®šè·¯å¾„ï¼‰
            const styleImg = new Image();
            styleImg.crossOrigin = 'Anonymous';
            styleImg.src = 'assets/img/style.jpg';

            // åŠ è½½å†…å®¹å›¾ç‰‡
            const contentImg = new Image();
            contentImg.crossOrigin = 'Anonymous';
            contentImg.src = contentBlobUrl;

            // ç­‰å¾…æ‰€æœ‰èµ„æºåŠ è½½å®Œæˆ
            await Promise.all([
                model.initialize(),
                new Promise((resolve) => { styleImg.onload = resolve; }),
                new Promise((resolve) => { contentImg.onload = resolve; })
            ]);

            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            canvas.width = contentImg.width;
            canvas.height = contentImg.height;

            // æ‰§è¡Œé£æ ¼åŒ–
            const imageData = await model.stylize(contentImg, styleImg);
            ctx.putImageData(imageData, 0, 0);

            // å°†ç”»å¸ƒè½¬æ¢ä¸ºBlobå¹¶ç”ŸæˆURL
            return new Promise((resolve) => {
                canvas.toBlob((blob) => {
                    const stylizedUrl = URL.createObjectURL(blob);
                    resolve(stylizedUrl);
                }, 'image/jpeg'); // å¯ä¿®æ”¹ä¸º'image/png'ç­‰å…¶ä»–æ ¼å¼
            });
        }
        // æ‘„åƒå¤´å¸§æ•è·ä¸ä¼ è¾“å‡½æ•°
        async function captureAndSendFrame() {
            const video = document.getElementById('webcam');

            // ç¡®ä¿è§†é¢‘å·²å°±ç»ª
            if (!video || video.readyState < HTMLMediaElement.HAVE_CURRENT_DATA) {
                console.warn('è§†é¢‘æµæœªå°±ç»ª');
                return;
            }

            try {
                // åˆ›å»ºç¦»å±Canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // è®¾ç½®Canvaså°ºå¯¸ä¸è§†é¢‘æºä¸€è‡´
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                // ç»˜åˆ¶é•œåƒç”»é¢ï¼ˆé€‚é…æ‘„åƒå¤´é•œåƒæ•ˆæœï¼‰
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                
                const blob = await new Promise((resolve, reject) => {
                    canvas.toBlob(blob => {
                        if (blob) resolve(blob);
                        else reject(new Error('Canvas toBlob failed'));
                    }, 'image/jpeg', 0.8);
                });
                
                img_url = URL.createObjectURL(blob);
                    
                // å†…å­˜æ¸…ç†
                canvas.width = 0;
                canvas.height = 0;
            } catch (err) {
                console.error('å¸§æ•è·å¤±è´¥:', err);
                throw new Error('FRAME_CAPTURE_ERROR');
            }
        }
        function get_img_url() {
            return [img_url, after_img_url];
        }
        window.get_img_url = get_img_url;

        //-----------------çˆ¶å­é¡µé¢é€šä¿¡------------------
        const Page_config = {
            1: {
                particleSize: 0.01,
                baseMotion: 0.01,
                cloudScale: 70.0,
                positionOffset: { x: 0, y: 25, z: 0 },
                rotation: { x: 0.5, y: 0.01 },
                cameraAnimation: {
                    enabled: true,
                    speed: 2,
                    points: [
                        { x: 0, y: 0, z: 50 },
                        { x: -20, y: 0, z: 70 }
                    ],
                    ease: "sine"
                },
                textOptions: [
                    "Chapterã€€1",
                    "æ¥ä¸‹æ¥ï¼Œæ‚¨å°†èº«å¤„è€ƒè¯•çš„åœºæ™¯",
                    "ä½“éªŒADHDæ‚£è€…çš„é˜…è¯»ä½“éªŒ"
                ],
                currentTextIndex: 0,
                textFadeDuration: 1000,
                characterDelay: 100,
                xyzFile: '/assets/pcloud/ljc.xyz'
            },
            2: {
                particleSize: 0.4,
                baseMotion: 0.01,
                cloudScale: 100.0,
                positionOffset: { x: 0, y: 25, z: 0 },
                rotation: { x: 0.0, y: 0 },
                cameraAnimation: {
                    enabled: true,
                    speed: 0.5,
                    points: [
                        { x: 50, y: 10, z: -70 },
                        { x: -50, y: 0, z: 70 }
                    ],
                    ease: "sine"
                },
                textOptions: [
                    "Chapterã€€2",
                    "ADHDæ‚£è€…å¾€å¾€åœ¨äº¤æµä¸Šæ„Ÿåˆ°å›°éš¾",
                    "æ¥ä¸‹æ¥è¯·æ‚¨å°†å±å¹•ä¸Šçš„å…³é”®è¯ç»„æˆæµåˆ©çš„å¥å­"
                ],
                currentTextIndex: 0,
                textFadeDuration: 1000,
                characterDelay: 100,
                xyzFile: '/assets/pcloud/2.xyz'
            },
            3: {
                particleSize: 0.25,
                baseMotion: 0.01,
                cloudScale: 100.0,
                positionOffset: { x: 0, y: 25, z: 0 },
                rotation: { x: 0.5, y: 0.01 },
                cameraAnimation: {
                    enabled: true,
                    speed: 1,
                    points: [
                        { x: 0, y: 0, z: 50 },
                        { x: -20, y: 0, z: 70 }
                    ],
                    ease: "sine"
                },
                textOptions: [
                    "Chapterã€€3",
                    "åœ¨ADHDçš„ä¸–ç•Œæ‹å¼ ç…§å§ï¼"
                ],
                currentTextIndex: 0,
                textFadeDuration: 1000,
                characterDelay: 100,
                xyzFile: '/assets/pcloud/3.xyz'
            },
        };

        const Pages_list = [
            `pages/setting.html`,
            `pages/chapter.html?config=${encodeURIComponent(JSON.stringify(Page_config[1]))}`,
            `pages/ADHD_PI.html`,
            `pages/chapter.html?config=${encodeURIComponent(JSON.stringify(Page_config[2]))}`,
            `pages/ADHD_PH.html`,
            `pages/chapter.html?config=${encodeURIComponent(JSON.stringify(Page_config[3]))}`,
            `pages/ADHD_C.html`,
            `pages/ADHD_INFO.html`,
            `pages/finish.html`,
        ];

        let Pages_index = 0;
        iframeManager.switchPage("pages/loading.html", 'fade');

        // æ€§èƒ½ä¼˜åŒ–ï¼šé˜²æŠ–æ¶ˆæ¯å¤„ç†
        const debouncedMessageHandler = debounce((data) => {
            console.log('Debounced message:', data);
        }, 100);

        window.addEventListener('message', function (event) {
            if (event.origin !== window.location.origin) return;

            const data = event.data;

            // å¤„ç†ç®€å•æ¶ˆæ¯
            switch (data) {
                case "next_page_PI":
                    gazePointElement.style.display = "none";
                    iframeManager.switchPage("pages/ADHD_PI.html", 'fade');
                    break;
                case "webcam":
                    enableCam();
                    break;
                case "webcam_face":
                    face_enableCam();
                    setTimeout(async () => {  // ğŸ‘‰ æ”¹ä¸ºasyncå‡½æ•°
                        // ç­‰å¾…æ•è·å®Œæˆåå†è¿›è¡Œé£æ ¼åŒ–
                        await captureAndSendFrame().catch(console.warn);

                        // ä½¿ç”¨æ–°æ•è·çš„img_urlè¿›è¡Œé£æ ¼åŒ–
                        const stylizedUrl = await stylizeImage(img_url);
                        after_img_url = stylizedUrl;

                    }, 5000);

                    break;
                case "webcam_hands":
                    // initializeHandTracking();
                    // toggleHandTracking();
                    break;
                case "load_module_now":
                    preloadModels();
                    break;
                case "startcalibration":
                    startCalibration();
                    break;
                case "video_frame":
                    handleVideoFrameInjection();
                    break;
                case 'page_loading_finish':
                    if (document.readyState === 'complete') {
                        iframeManager.switchPage(Pages_list[Pages_index], 'fade');
                        Pages_index++;
                    } else {
                        try {
                            const currentFrame = iframeManager.getCurrentFrame();
                            if (currentFrame?.contentWindow) {
                                currentFrame.contentWindow.postMessage('action_wait', '*');
                            }
                        } catch (err) {
                            // å¿½ç•¥è·¨åŸŸé”™è¯¯
                        }
                    }
                    break;
                case 'page_setting_finish':
                case 'page_chapter_finish':
                    iframeManager.switchPage(Pages_list[Pages_index], 'fade');
                    Pages_index++;
                    break;
                case 'page_adhd_pi_finish':
                    enableCam();
                    iframeManager.switchPage(Pages_list[Pages_index], 'fade');
                    Pages_index++;
                    break;
                case 'page_adhd_ph_finish':
                    // toggleHandTracking();
                    iframeManager.switchPage(Pages_list[Pages_index], 'fade');
                    Pages_index++;
                    break;
                case 'page_adhd_c_finish':
                    face_enableCam();
                    iframeManager.switchPage(Pages_list[Pages_index], 'fade');
                    Pages_index++;
                    break;
                case 'page_adhd_info_finish':
                    iframeManager.switchPage(Pages_list[Pages_index], 'fade');
                    Pages_index++;
                    break;
                case 'finish_text_loaded':
                    const currentFrame = iframeManager.getCurrentFrame();
                    const message = {
                        type: "img",
                        url: img_url,
                    };
                    currentFrame.contentWindow.postMessage(message, '*');
                    break;
            }

            debouncedMessageHandler(data);
        });

        // æ€§èƒ½ä¼˜åŒ–ï¼šè§†é¢‘å¸§æ³¨å…¥å‡½æ•°
        function handleVideoFrameInjection() {
            const currentFrame = iframeManager.getCurrentFrame();
            const maxAttempts = 3;
            const retryInterval = 1000; // å‡å°‘é‡è¯•é—´éš”
            let attempts = 0;

            const tryInjectStream = () => {
                    attempts++;
                    try {
                        if (!video.srcObject) {
                            throw new Error('çˆ¶é¡µé¢è§†é¢‘æµæœªå‡†å¤‡å¥½');
                        }

                        const childVideo = currentFrame.contentDocument?.getElementById('webcam');
                        if (!childVideo) {
                            throw new Error('å­é¡µé¢videoå…ƒç´ ä¸å­˜åœ¨');
                        }

                        childVideo.srcObject = video.srcObject;
                        childVideo.muted = true;
                        childVideo.style.display = 'block';

                        return childVideo.play().then(() => {
                            console.log('è§†é¢‘æµæ³¨å…¥æˆåŠŸ');
                        }).catch(err => {
                            throw new Error(`æ’­æ”¾å¤±è´¥: ${err.message}`);
                        });

                    } catch (err) {
                        if (attempts >= maxAttempts) {
                            console.error(`è§†é¢‘æµæ³¨å…¥å¤±è´¥ï¼Œå·²å°è¯• ${attempts} æ¬¡`, err);
                            return;
                        }
                        console.warn(`ç¬¬ ${attempts} æ¬¡å°è¯•å¤±è´¥ï¼Œ${retryInterval}msåé‡è¯•...`);
                        setTimeout(tryInjectStream, retryInterval);
                    }
            };

            tryInjectStream();
        }

    </script>
</body>

</html>